@page "/game/{GameCode}"
@inherits AsyncComponentBase
@using SleepingQueens.Client.Components
@using SleepingQueens.Client.Services
@using SleepingQueens.Shared.Models.DTOs
@using SleepingQueens.Shared.Models.Game.Enums
@using System.Diagnostics
@inject ISignalRService SignalRService
@inject NavigationManager Navigation

<PageTitle>Game - @GameCode</PageTitle>

@if (gameState == null)
{
    <div class="loading">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p>Loading game...</p>
    </div>
}
else
{
    <div class="game-layout">
        <!-- ========== HEADER ========== -->
        <header class="game-header">
            <div>
                <button class="btn btn-sm btn-outline-secondary" @onclick="ReturnToLobby">
                    ← Return to Lobby
                </button>
            </div>

            <div class="target-score">
                <span class="score-label">Target:</span>
                <span class="score-value">@gameState.Game?.TargetScore</span>
            </div>

            <div class="turn-indicator @(isPlayerTurn ? "player-turn" : "opponent-turn")">
                @if (isPlayerTurn)
                {
                    <span class="turn-text">YOUR TURN</span>
                }
                else
                {
                    <span class="turn-text">@gameState.CurrentPlayer?.Name's Turn</span>
                }
            </div>

            <div class="game-code">
                <span class="code-label">Game:</span>
                <span class="code-value">@gameState.Game?.Code</span>
            </div>

            <div>
                <div class="game-status">
                    <span class="status-badge @GetPhaseBadgeClass()">@gameState.Game?.Phase</span>
                </div>
            </div>
        </header>

        <!-- ========== OPPONENT AREA ========== -->
        <section class="opponent-area">
            <div class="opponent-tabs">
                @foreach (var opponent in GetOpponents())
                {
                    <button class="opponent-tab @(selectedOpponentId == opponent.Id ? "active" : "")"
                            @onclick="() => SelectOpponent(opponent.Id)">
                        <span class="opponent-name">@opponent.Name</span>
                        <span class="opponent-stats">
                            Q:<span class="stat-value">@opponent.Queens?.Count</span>
                            S:<span class="stat-value">@opponent.Score</span>
                        </span>
                    </button>
                }
            </div>

            @if (selectedOpponent != null)
            {
                <div class="opponent-details">
                    <div class="opponent-cards">
                        <h6>@selectedOpponent.Name's Cards (@selectedOpponent.Hand.Count)</h6>
                        <div class="cards-row">
                            @for (int i = 0; i < selectedOpponent.Hand.Count; i++)
                            {
                                <CardDisplay IsFaceDown="true"
                                             AdditionalClasses="opponent-card"
                                             IsClickable="false" />
                            }
                        </div>
                    </div>

                    <div class="opponent-queens">
                        <h6>@selectedOpponent.Name's Queens</h6>
                        <div class="queens-row">
                            @foreach (var queen in selectedOpponent.Queens ?? Enumerable.Empty<QueenDto>())
                            {
                                var queenTitle = "@queen.Name(@queen.PointValue pts)";
                                <QueenDisplay Queen="queen"
                                              IsAwake="true"
                                              AdditionalClasses="queen-token"
                                              Title="@queenTitle" />
                            }
                        </div>
                    </div>
                </div>
            }
        </section>

        <!-- ========== SLEEPING QUEENS ========== -->
        <section class="sleeping-queens-section">
            <div class="sleeping-queens-grid">
                @{
                    List<QueenDto> queens = (gameState.SleepingQueens ?? Enumerable.Empty<QueenDto>()).ToList();
                    int halfQueens = queens.Count() / 2;
                    for (int i = 0; i < halfQueens; i++)
                    {
                        <QueenDisplay Queen="queens[i]"
                                      IsSelected="selectedQueenId == queens[i].Id"
                                      IsFaceDown="true"
                                      OnQueenIdClick="() => SelectQueen(queens[i].Id)"
                                      IsClickable="@isPlayerTurn" />
                    }

                    <!-- ========== DECK & DISCARD ========== -->
                    <div class="deck-area">
                        <div class="deck" @onclick="DrawCard" title="Click to draw card">
                        </div>
                        <div class="discard" title="Discard Pile">
                            @if (gameState.DiscardPile?.Count > 0)
                            {
                                <!-- Show the last discarded card on top -->
                                <div class="discard-card">
                                    <CardDisplay Card="lastDiscardedCard"
                                                 AdditionalClasses="discarded-card"
                                                 IsClickable="true"
                                                 OnCardClick="ShowDiscardHistory" />
                                </div>

                                // <!-- Show stack indicator for cards underneath -->
                                // @if (gameState.DiscardPile.Count > 1)
                                // {
                                //     <div class="card-stack">
                                //         @for (int i = 0; i < Math.Min(3, gameState.DiscardPile.Count - 1); i++)
                                //         {
                                //             <div class="stacked-card" style="transform: translate(@(i * 2)px, @(i * 2)px);"></div>
                                //         }
                                //         @if (gameState.DiscardPile.Count > 4)
                                //         {
                                //             <div class="stack-count">+@(gameState.DiscardPile.Count - 4)</div>
                                //         }
                                //     </div>
                                // }
                            }
                            else
                            {
                                <div class="discard-pile-empty">Discard</div>
                            }

                            
                        </div>
                    </div>

                    for (int i = halfQueens; i < queens.Count(); i++)
                    {
                        <QueenDisplay Queen="queens[i]"
                                      IsSelected="selectedQueenId == queens[i].Id"
                                      IsFaceDown="true"
                                      OnQueenIdClick="() => SelectQueen(queens[i].Id)"
                                      IsClickable="@isPlayerTurn" />
                    }

                }
            </div>
        </section>

        <!-- ========== PLAYER AREA ========== -->
        <section class="player-area">
            <div class="player-header">
                <div class="player-info-left">
                    <h4>@currentPlayerName</h4>
                </div>

                <div class="player-info-center">
                    <div class="selected-count">
                        <span class="count-badge">@selectedCards.Count</span>
                        <span class="count-label">cards selected</span>
                    </div>
                </div>

                <div class="player-info-right">
                    <div class="player-score">
                        <span class="score-label">Score:</span>
                        <span class="score-value">@currentPlayerScore</span>
                    </div>
                </div>
            </div>



            <!-- Action Buttons -->
            <div class="action-buttons-row">
                <button class="btn btn-primary action-btn" @onclick="PlaySelectedCard"
                        @disabled="@(!CanPlaySelectedCard())"
                        title="@GetPlayButtonTooltip()">
                    <span class="btn-text">Play Card</span>
                </button>

                <button class="btn btn-secondary action-btn" @onclick="DiscardSelected"
                        @disabled="@(!CanDiscardSelected())"
                        title="@GetDiscardButtonTooltip()">
                    <span class="btn-text">Discard</span>
                </button>

                <button class="btn btn-success action-btn" @onclick="EndTurn"
                        @disabled="@(!CanEndTurn())"
                        title="End your turn (must have 5 cards)">
                    <span class="btn-text">End Turn</span>
                </button>

                @if (IsBeingAttacked)
                {
                    <div class="defense-buttons">
                        @if (HasDragonCard())
                        {
                            <button class="btn btn-danger action-btn btn-sm" @onclick="PlayDragon">
                                <span class="btn-text">Defend with Dragon</span>
                            </button>
                        }
                        @if (HasWandCard())
                        {
                            <button class="btn btn-info action-btn btn-sm" @onclick="PlayWand">
                                <span class="btn-text">Defend with Wand</span>
                            </button>
                        }
                    </div>
                }
            </div>

            <!-- Player's Cards and Queens -->
            <div class="player-content">
                <div class="player-cards">
                    <h6>Your Hand (@currentPlayerHand.Count/5)</h6>
                    <div class="cards-grid">
                        @foreach (var card in currentPlayerHand)
                        {
                            <CardDisplay Card="card"
                                         IsSelected="selectedCards.Contains(card.Id)"
                                         OnCardIdClick="() => ToggleCardSelection(card.Id)"
                                         IsClickable="@isPlayerTurn" />
                        }
                    </div>
                </div>

                <div class="player-queens">
                    <h6>Your Queens</h6>
                    <div class="queens-grid">
                        @foreach (var queen in currentPlayerQueens)
                        {
                            var queenTitle = "@queen.Name(@queen.PointValue pts)";
                            <QueenDisplay Queen="queen"
                                          IsAwake="true"
                                          Title="@queenTitle" />
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- ========== FOOTER ========== -->
        <footer class="game-footer">
            <div class="chat-preview" @onclick="ToggleChatModal">
                <div class="latest-message">
                    @if (chatMessages.Count > 0)
                    {
                        var latest = chatMessages.Last();
                        <span class="sender">@latest.PlayerName:</span>
                        <span class="message">@latest.Message</span>
                    }
                    else
                    {
                        <span class="no-messages">No messages yet</span>
                    }
                </div>
                <button class="btn btn-sm btn-outline-secondary chat-toggle">
                    💬
                </button>
            </div>
            <div class="status-container">
                <!-- Status Messages -->
                @if (!string.IsNullOrEmpty(actionStatus))
                {
                    <div class="action-status alert alert-info">
                        @actionStatus
                    </div>
                }
                @if (!string.IsNullOrEmpty(lastErrorMessage))
                {
                    <div class="action-status alert alert-danger">
                        @lastErrorMessage
                    </div>
                }
            </div>
            <div class="chat-input">
                <input type="text" class="form-control chat-box"
                       @bind="chatMessage"
                       placeholder="Type a message..."
                       @onkeypress="HandleChatKeyPress" />
                <button class="btn btn-primary" @onclick="SendChatMessage">
                    Send
                </button>
            </div>
        </footer>
    </div>

    <!-- Chat Modal -->
    @if (showChatModal)
    {
        <div class="chat-modal-backdrop" @onclick="ToggleChatModal"></div>
        <div class="chat-modal">
            <div class="chat-modal-header">
                <h5>Game Chat</h5>
                <button class="btn-close" @onclick="ToggleChatModal"></button>
            </div>
            <div class="chat-modal-body">
                @foreach (var message in chatMessages)
                {
                    <div class="chat-message">
                        <strong>@message.PlayerName:</strong> @message.Message
                    </div>
                }
            </div>
        </div>
    }

    <!-- Discard History Modal -->
    @if (showDiscardHistory && gameState?.DiscardPile?.Count > 0)
    {
        {
            <div class="discard-history-backdrop" @onclick="HideDiscardHistory"></div>
        }

        <div class="discard-history-popup">
            <div class="popup-header">
                <h6>Discard History</h6>
                <button class="btn-close" @onclick="HideDiscardHistory"></button>
            </div>
            <div class="popup-content">
                @if (gameState != null)
                {
                    List<CardDto> reversePile = gameState.DiscardPile.Reverse<CardDto>().ToList();
                    @foreach (var card in gameState.DiscardPile)
                    {
                        <div class="history-item">
                            <CardDisplay Card="card"
                                         AdditionalClasses="history-card"
                                         IsClickable="false" />
                        </div>
                    }
                }
            </div>
        </div>
    }
}

@code {
    [Parameter] public string GameCode { get; set; } = string.Empty;

    [SupplyParameterFromQuery(Name = "playerId")]
    public Guid? PlayerId { get; set; }

    private GameStateDto? gameState;
    private List<ChatMessageDisplay> chatMessages = new();
    private string chatMessage = string.Empty;
    private List<Guid> selectedCards = new();
    private Guid? selectedQueenId;
    private Guid? selectedPlayerId;
    private bool isPlayerTurn = false;
    private Guid? _currentPlayerId;
    private Guid? _currentGameId;
    private string actionStatus = string.Empty;
    private bool showChatModal = false;
    private bool isBeingAttacked = false;
    private Guid? selectedOpponentId;
    private PlayerDto? selectedOpponent;
    private string currentPlayerName = string.Empty;
    private int currentPlayerScore = 0;
    private List<CardDto> currentPlayerHand = new();
    private List<QueenDto> currentPlayerQueens = new();
    private CardDto? lastDiscardedCard;
    public string lastErrorMessage { get; set; } = string.Empty;
    private bool showDiscardHistory = false;

    protected override async Task OnInitializedAsync()
    {
        await SignalRService.ConnectAsync();
        SetupEventSubscriptions();
        await LoadGameState();
    }

    private void SetupEventSubscriptions()
    {
        SignalRService.OnGameStateUpdated.Subscribe(HandleGameStateUpdatedAsync);
        SignalRService.OnChatMessage.Subscribe(HandleChatMessageAsync);
        SignalRService.OnConnectionStatusChanged.Subscribe(HandleConnectionStatusChangedAsync);
        SignalRService.OnGameActionResponse.Subscribe(HandleGameActionResponseAsync);
        // TODO: Add subscription for attack events
    }

    private async Task LoadGameState()
    {
        if (PlayerId.HasValue)
        {
            _currentPlayerId = PlayerId;
        }
        _currentGameId = await GetGameIdFromCode(GameCode);
        if (_currentGameId.HasValue)
        {
            var response = await SignalRService.GetGameStateAsync(_currentGameId.Value);
            if (response.Success && response.Data != null)
            {
                UpdateGameState(response.Data);
            }
        }
    }

    private async Task<Guid?> GetGameIdFromCode(string gameCode)
    {
        var response = await SignalRService.GetActiveGamesAsync();
        if (response.Success && response.Data != null)
        {
            return response.Data.FirstOrDefault(g => g.GameCode == gameCode)?.GameId;
        }
        return null;
    }

    private void UpdateGameState(GameStateDto newState)
    {
        gameState = newState;
        UpdatePlayerInfo();
        UpdateSelectedOpponent();
        UpdateLastDiscardedCard();
        StateHasChanged();
    }

    private void UpdatePlayerInfo()
    {
        if (gameState == null || !_currentPlayerId.HasValue) return;

        var player = gameState.Players?.FirstOrDefault(p => p.Id == _currentPlayerId.Value);
        if (player != null)
        {
            currentPlayerName = player.Name;
            currentPlayerScore = player.Score;
            currentPlayerHand = player.Hand?.ToList() ?? new List<CardDto>();
            currentPlayerQueens = player.Queens?.ToList() ?? new List<QueenDto>();
            isPlayerTurn = gameState.CurrentPlayer?.Id == _currentPlayerId.Value;
        }
    }

    private void UpdateSelectedOpponent()
    {
        if (gameState?.Players == null || !_currentPlayerId.HasValue) return;

        // Set first opponent as selected if none selected
        var opponents = GetOpponents().ToList();
        if (!selectedOpponentId.HasValue && opponents.Any())
        {
            selectedOpponentId = opponents.First().Id;
        }

        selectedOpponent = opponents.FirstOrDefault(o => o.Id == selectedOpponentId);
    }

    private void UpdateLastDiscardedCard()
    {
        if (gameState?.DiscardPile?.Count > 0)
        {
            lastDiscardedCard = gameState?.DiscardPile?.Last();
        }
        else
        {
            lastDiscardedCard = null;
        }
    }

    private IEnumerable<PlayerDto> GetOpponents()
    {
        if (gameState?.Players == null || !_currentPlayerId.HasValue)
            return Enumerable.Empty<PlayerDto>();

        return gameState.Players.Where(p => p.Id != _currentPlayerId.Value);
    }

    private void SelectOpponent(Guid opponentId)
    {
        selectedOpponentId = opponentId;
        UpdateSelectedOpponent();
        StateHasChanged();
    }

    private void CheckForAttacks()
    {
        // TODO: Implement logic to check if player is being attacked
        // This would come from game state or events
        isBeingAttacked = false; // Temporary
    }

    private async Task HandleChatMessageAsync((string PlayerName, string Message) chatData)
    {
        await InvokeAsync(() =>
        {
            chatMessages.Add(new ChatMessageDisplay
            {
                PlayerName = chatData.PlayerName,
                Message = chatData.Message
            });
            // Keep only last 50 messages
            if (chatMessages.Count > 50)
                chatMessages.RemoveAt(0);
            StateHasChanged();
        });
    }

    private async Task HandleConnectionStatusChangedAsync(string status)
    {
        await InvokeAsync(() =>
        {
            Console.WriteLine($"Connection status changed: {status}");
            StateHasChanged();
        });
    }

    private async Task HandleGameActionResponseAsync(ApiResponse response)
    {
        await InvokeAsync(() =>
        {
            if (!response.Success && !string.IsNullOrEmpty(response.ErrorMessage))
            {
                lastErrorMessage = response.ErrorMessage;
            }
            else if (response.Success)
            {
                lastErrorMessage = string.Empty;
            }
            StateHasChanged();
        });
    }

    // ========== CARD SELECTION LOGIC ==========
    private void ToggleCardSelection(Guid cardId)
    {
        if (!isPlayerTurn) return;

        if (selectedCards.Contains(cardId))
        {
            selectedCards.Remove(cardId);
        }
        else
        {
            // Limit selection based on action type
            var card = currentPlayerHand.FirstOrDefault(c => c.Id == cardId);
            if (card != null)
            {
                if (card.Type == CardType.Jester || card.Type == CardType.King ||
                    card.Type == CardType.Knight || card.Type == CardType.SleepingPotion)
                {
                    // Single card actions - clear other selections
                    selectedCards.Clear();
                }
                else if (card.Type == CardType.Number)
                {
                    // For discard actions, allow multiple number cards
                }
                selectedCards.Add(cardId);
            }
        }
        UpdateActionStatus();
        StateHasChanged();
    }

    private void SelectPlayer(Guid playerId)
    {
        if (!isPlayerTurn) return;

        selectedPlayerId = playerId;
        selectedQueenId = null;
        UpdateActionStatus();
        StateHasChanged();
    }

    private void SelectQueen(Guid queenId)
    {
        if (!isPlayerTurn) return;

        selectedQueenId = queenId;
        selectedPlayerId = null;
        UpdateActionStatus();
        StateHasChanged();
    }

    private void UpdateActionStatus()
    {
        actionStatus = string.Empty;

        if (selectedCards.Count == 1)
        {
            var card = currentPlayerHand.FirstOrDefault(c => c.Id == selectedCards.First());
            if (card != null)
            {
                switch (card.Type)
                {
                    case CardType.King:
                        if (selectedQueenId == null)
                            actionStatus = "Select a sleeping queen to awaken";
                        else
                            actionStatus = "Ready to awaken queen";
                        break;
                    case CardType.Knight:
                        if (selectedPlayerId == null)
                            actionStatus = "Select an opponent to steal from";
                        else
                            actionStatus = "Ready to steal from opponent";
                        break;
                    case CardType.SleepingPotion:
                        if (selectedPlayerId == null)
                            actionStatus = "Select an opponent to put to sleep";
                        else
                            actionStatus = "Ready to use sleeping potion";
                        break;
                    case CardType.Jester:
                        actionStatus = "Play Jester - draw a card and see what happens!";
                        break;
                    case CardType.Number:
                        actionStatus = "Select more cards to discard or play individually";
                        break;
                }
            }
        }
        else if (selectedCards.Count > 1)
        {
            var selectedCardTypes = currentPlayerHand
                .Where(c => selectedCards.Contains(c.Id))
                .Select(c => c.Type)
                .ToList();

            if (selectedCardTypes.All(t => t == CardType.Number))
            {
                if (selectedCards.Count == 2)
                {
                    // Check for identical numbers
                    var numbers = currentPlayerHand
                        .Where(c => selectedCards.Contains(c.Id))
                        .Select(c => c.Value)
                        .ToList();

                    if (numbers[0] == numbers[1])
                        actionStatus = "Ready to discard pair of identical numbers";
                    else
                        actionStatus = "Can only discard identical number pairs";
                }
                else if (selectedCards.Count >= 3)
                {
                    actionStatus = "Check if selected numbers form a valid addition equation";
                }
            }
            else
            {
                actionStatus = "Can only discard multiple number cards";
            }
        }
    }

    private void ShowDiscardHistory()
    {
        if (gameState?.DiscardPile?.Count > 0)
        {
            showDiscardHistory = true;
            StateHasChanged();
        }
    }

    private void HideDiscardHistory()
    {
        showDiscardHistory = false;
        StateHasChanged();
    }

    // ========== GAME ACTION VALIDATION ==========
    private bool CanPlaySelectedCard()
    {
        if (!isPlayerTurn || selectedCards.Count != 1) return false;

        var card = currentPlayerHand.FirstOrDefault(c => c.Id == selectedCards.First());
        if (card == null) return false;

        return card.Type switch
        {
            CardType.King => selectedQueenId != null,
            CardType.Knight => selectedPlayerId != null &&
                             GetOpponents().Any(o => o.Id == selectedPlayerId &&
                                                   o.Queens?.Count > 0),
            CardType.SleepingPotion => selectedPlayerId != null &&
                                     GetOpponents().Any(o => o.Id == selectedPlayerId &&
                                                           o.Queens?.Count > 0),
            CardType.Jester => true,
            CardType.Dragon or CardType.Wand => true, // For defense
            _ => false
        };
    }

    private bool CanDiscardSelected()
    {
        if (!isPlayerTurn || selectedCards.Count == 0) return false;

        var selectedCardObjects = currentPlayerHand
            .Where(c => selectedCards.Contains(c.Id))
            .ToList();

        // Single card discard (any type)
        if (selectedCards.Count == 1) return true;

        // All selected cards must be numbers
        if (!selectedCardObjects.All(c => c.Type == CardType.Number)) return false;

        // Two identical numbers
        if (selectedCards.Count == 2)
        {
            var values = selectedCardObjects.Select(c => c.Value).ToList();
            return values[0] == values[1];
        }

        // Three or more numbers - check for valid addition equation
        if (selectedCards.Count >= 3)
        {
            return CanFormValidAddition(selectedCardObjects);
        }

        return false;
    }

    private bool CanEndTurn()
    {
        if (!isPlayerTurn) return false;

        // Player must have 5 cards to end turn
        return currentPlayerHand.Count == 5;
    }

    private bool IsBeingAttacked => isBeingAttacked;

    private bool HasDefenseCard()
    {
        return HasDragonCard() || HasWandCard();
    }

    private bool HasDragonCard()
    {
        return currentPlayerHand.Any(c => c.Type == CardType.Dragon);
    }

    private bool HasWandCard()
    {
        return currentPlayerHand.Any(c => c.Type == CardType.Wand);
    }

    private bool CanFormValidAddition(List<CardDto> cards)
    {
        // Check if selected numbers can form a valid addition equation
        // where one number equals the sum of the others
        var numbers = cards.Select(c => c.Value).ToList();

        // Try all combinations where one number is the sum
        for (int i = 0; i < numbers.Count; i++)
        {
            var sum = numbers[i];
            var remaining = numbers.Where((_, idx) => idx != i).ToList();

            // Check if remaining numbers can sum to this value
            if (remaining.Sum() == sum)
                return true;
        }

        return false;
    }

    private string GetPlayButtonTooltip()
    {
        if (!CanPlaySelectedCard())
        {
            if (selectedCards.Count != 1) return "Select exactly one card to play";

            var card = currentPlayerHand.FirstOrDefault(c => c.Id == selectedCards.First());
            return card?.Type switch
            {
                CardType.King => "Select a sleeping queen to awaken",
                CardType.Knight => "Select an opponent with queens to steal from",
                CardType.SleepingPotion => "Select an opponent with queens to put to sleep",
                _ => "Cannot play this card"
            };
        }
        return "Play selected card";
    }

    private string GetDiscardButtonTooltip()
    {
        if (!CanDiscardSelected())
        {
            if (selectedCards.Count == 0) return "Select cards to discard";

            if (selectedCards.Count == 1) return "Ready to discard single card";

            if (selectedCards.Count == 2)
                return "Can only discard two identical number cards";

            return "Selected numbers must form a valid addition equation";
        }

        return selectedCards.Count == 1 ? "Discard single card" : "Discard selected cards";
    }

    // ========== GAME ACTIONS ==========
    private async Task PlaySelectedCard()
    {
        if (!CanPlaySelectedCard() || !_currentGameId.HasValue) return;

        var cardId = selectedCards.First();
        var request = new PlayCardRequest
        {
            GameId = _currentGameId.Value,
            CardId = cardId,
            TargetPlayerId = selectedPlayerId,
            TargetQueenId = selectedQueenId
        };

        var response = await SignalRService.PlayCardAsync(request);
        if (!response.Success)
        {
            lastErrorMessage = response.ErrorMessage ?? "Failed to play card";
        }
        else
        {
            actionStatus = "Card played successfully!";
        }
    }

    private async Task DiscardSelected()
    {
        if (!CanDiscardSelected() || !_currentGameId.HasValue) return;

        var response = await SignalRService.DiscardCardsAsync(_currentGameId.Value, selectedCards);
        if (!response.Success)
        {
            lastErrorMessage = response.ErrorMessage ?? "Failed to discard cards";
        }
        else
        {
            actionStatus = "Cards discarded successfully!";
            if (response.Data != null)
            {
                UpdateGameState(response.Data);
            }
        }
    }

    private async Task EndTurn()
    {
        if (!CanEndTurn() || !_currentGameId.HasValue) return;

        var response = await SignalRService.EndTurnAsync(_currentGameId.Value);
        if (!response.Success)
        {
            lastErrorMessage = response.ErrorMessage ?? "Failed to end turn";
        }
        else
        {
            actionStatus = "Turn ended!";
        }
    }

    private async Task DrawCard()
    {
        if (!isPlayerTurn || !_currentGameId.HasValue) return;

        // Only allow drawing if hand has less than 5 cards
        if (currentPlayerHand.Count >= 5)
        {
            actionStatus = "You already have 5 cards!";
            return;
        }

        var response = await SignalRService.DrawCardAsync(_currentGameId.Value);
        if (!response.Success)
        {
            lastErrorMessage = response.ErrorMessage ?? "Failed to draw card";
        }
    }

    private async Task PlayDragon()
    {
        if (!isBeingAttacked || !HasDragonCard() || !_currentGameId.HasValue) return;

        // TODO: Implement dragon defense API
        actionStatus = "Playing Dragon to defend!";
    }

    private async Task PlayWand()
    {
        if (!isBeingAttacked || !HasWandCard() || !_currentGameId.HasValue) return;

        // TODO: Implement wand defense API
        actionStatus = "Playing Wand to defend!";
    }

    // ========== HELPER METHODS ==========
    private async Task SendChatMessage()
    {
        if (!string.IsNullOrWhiteSpace(chatMessage) && _currentGameId.HasValue)
        {
            await SignalRService.SendMessageAsync(_currentGameId.Value, chatMessage);
            chatMessage = string.Empty;
        }
    }

    private async Task HandleChatKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendChatMessage();
        }
    }

    private void ReturnToLobby()
    {
        Navigation.NavigateTo($"/lobby/{GameCode}");
    }

    private string GetPhaseBadgeClass()
    {
        return gameState?.Game?.Phase switch
        {
            GamePhase.Setup => "bg-secondary",
            GamePhase.Playing => "bg-success",
            GamePhase.Scoring => "bg-warning",
            GamePhase.Ended => "bg-danger",
            _ => "bg-secondary"
        };
    }

    private void ToggleChatModal()
    {
        showChatModal = !showChatModal;
    }


    private async Task HandleGameStateUpdatedAsync(GameStateDto newState)
    {
        await InvokeAsync(() =>
        {
            showDiscardHistory = false;
            UpdateGameState(newState);
            selectedCards.Clear();
            selectedQueenId = null;
            selectedPlayerId = null;
            actionStatus = string.Empty;
            StateHasChanged();
        });
    }



    private class ChatMessageDisplay
    {
        public string PlayerName { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
    }
}